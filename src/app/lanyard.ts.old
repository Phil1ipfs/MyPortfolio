/**
 * Lanyard - 3D Physics-based ID Card with Lanyard
 * Converted from React Three Fiber to vanilla Three.js + Rapier
 */

import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import RAPIER from '@dimforge/rapier3d-compat';
import { MeshLineGeometry, MeshLineMaterial } from 'meshline';

export interface LanyardOptions {
  position?: [number, number, number];
  gravity?: [number, number, number];
  fov?: number;
  transparent?: boolean;
  cardGLBPath?: string;
  lanyardTexturePath?: string;
}

export class Lanyard {
  private container: HTMLElement;
  private scene: THREE.Scene;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer;
  private world?: RAPIER.World;
  private options: Required<LanyardOptions>;

  // Rigid bodies
  private fixedBody?: RAPIER.RigidBody;
  private j1Body?: RAPIER.RigidBody;
  private j2Body?: RAPIER.RigidBody;
  private j3Body?: RAPIER.RigidBody;
  private cardBody?: RAPIER.RigidBody;

  // Three.js objects
  private cardMesh?: THREE.Group;
  private bandMesh?: THREE.Mesh;
  private curve: THREE.CatmullRomCurve3;

  // Animation state
  private rafId?: number;
  private dragged: false | THREE.Vector3 = false;
  private hovered = false;
  private j1Lerped = new THREE.Vector3();
  private j2Lerped = new THREE.Vector3();

  // Mouse
  private mouse = new THREE.Vector2();
  private raycaster = new THREE.Raycaster();

  constructor(container: HTMLElement, options: LanyardOptions = {}) {
    this.container = container;
    this.options = {
      position: options.position ?? [0, 0, 30],
      gravity: options.gravity ?? [0, -40, 0],
      fov: options.fov ?? 20,
      transparent: options.transparent ?? true,
      cardGLBPath: options.cardGLBPath ?? '/card.glb',
      lanyardTexturePath: options.lanyardTexturePath ?? '/lanyard.png'
    };

    this.curve = new THREE.CatmullRomCurve3([
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ]);
    this.curve.curveType = 'chordal';

    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(
      this.options.fov,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    this.renderer = new THREE.WebGLRenderer({
      alpha: this.options.transparent,
      antialias: true
    });

    this.init();
  }

  private async init() {
    // Setup renderer
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setClearColor(0x000000, this.options.transparent ? 0 : 1);
    this.container.appendChild(this.renderer.domElement);

    // Setup camera
    this.camera.position.set(...this.options.position);

    // Setup lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, Math.PI);
    this.scene.add(ambientLight);

    // Add environment lights (simulating Lightformers)
    this.addEnvironmentLights();

    // Initialize physics
    await this.initPhysics();

    // Load assets and create band
    await this.loadAssets();

    // Setup event listeners
    this.setupEventListeners();

    // Start animation loop
    this.animate();
  }

  private addEnvironmentLights() {
    const lights = [
      { intensity: 2, color: 0xffffff, position: [0, -1, 5] },
      { intensity: 3, color: 0xffffff, position: [-1, -1, 1] },
      { intensity: 3, color: 0xffffff, position: [1, 1, 1] },
      { intensity: 10, color: 0xffffff, position: [-10, 0, 14] }
    ];

    lights.forEach(({ intensity, color, position }) => {
      const light = new THREE.DirectionalLight(color, intensity);
      light.position.set(position[0], position[1], position[2]);
      this.scene.add(light);
    });
  }

  private async initPhysics() {
    await RAPIER.init();
    const gravity = new RAPIER.Vector3(...this.options.gravity);
    this.world = new RAPIER.World(gravity);

    // Create rigid bodies
    const segmentProps = {
      angularDamping: 4,
      linearDamping: 4
    };

    // Fixed anchor point
    const fixedDesc = RAPIER.RigidBodyDesc.fixed().setTranslation(0, 4, 0);
    this.fixedBody = this.world.createRigidBody(fixedDesc);

    // Joint 1
    const j1Desc = RAPIER.RigidBodyDesc.dynamic()
      .setTranslation(0.5, 4, 0)
      .setAngularDamping(segmentProps.angularDamping)
      .setLinearDamping(segmentProps.linearDamping)
      .setCanSleep(true);
    this.j1Body = this.world.createRigidBody(j1Desc);
    const j1Collider = RAPIER.ColliderDesc.ball(0.1);
    this.world.createCollider(j1Collider, this.j1Body);

    // Joint 2
    const j2Desc = RAPIER.RigidBodyDesc.dynamic()
      .setTranslation(1, 4, 0)
      .setAngularDamping(segmentProps.angularDamping)
      .setLinearDamping(segmentProps.linearDamping)
      .setCanSleep(true);
    this.j2Body = this.world.createRigidBody(j2Desc);
    const j2Collider = RAPIER.ColliderDesc.ball(0.1);
    this.world.createCollider(j2Collider, this.j2Body);

    // Joint 3
    const j3Desc = RAPIER.RigidBodyDesc.dynamic()
      .setTranslation(1.5, 4, 0)
      .setAngularDamping(segmentProps.angularDamping)
      .setLinearDamping(segmentProps.linearDamping)
      .setCanSleep(true);
    this.j3Body = this.world.createRigidBody(j3Desc);
    const j3Collider = RAPIER.ColliderDesc.ball(0.1);
    this.world.createCollider(j3Collider, this.j3Body);

    // Card
    const cardDesc = RAPIER.RigidBodyDesc.dynamic()
      .setTranslation(2, 4, 0)
      .setAngularDamping(segmentProps.angularDamping)
      .setLinearDamping(segmentProps.linearDamping)
      .setCanSleep(true);
    this.cardBody = this.world.createRigidBody(cardDesc);
    const cardCollider = RAPIER.ColliderDesc.cuboid(0.8, 1.125, 0.01);
    this.world.createCollider(cardCollider, this.cardBody);

    // Create rope joints
    if (this.fixedBody && this.j1Body) {
      const anchor1 = new RAPIER.Vector3(0, 0, 0);
      const anchor2 = new RAPIER.Vector3(0, 0, 0);
      const ropeJoint1 = RAPIER.JointData.rope(1, anchor1, anchor2);
      this.world.createImpulseJoint(ropeJoint1, this.fixedBody, this.j1Body, true);
    }

    if (this.j1Body && this.j2Body) {
      const anchor1 = new RAPIER.Vector3(0, 0, 0);
      const anchor2 = new RAPIER.Vector3(0, 0, 0);
      const ropeJoint2 = RAPIER.JointData.rope(1, anchor1, anchor2);
      this.world.createImpulseJoint(ropeJoint2, this.j1Body, this.j2Body, true);
    }

    if (this.j2Body && this.j3Body) {
      const anchor1 = new RAPIER.Vector3(0, 0, 0);
      const anchor2 = new RAPIER.Vector3(0, 0, 0);
      const ropeJoint3 = RAPIER.JointData.rope(1, anchor1, anchor2);
      this.world.createImpulseJoint(ropeJoint3, this.j2Body, this.j3Body, true);
    }

    if (this.j3Body && this.cardBody) {
      const anchor1 = new RAPIER.Vector3(0, 0, 0);
      const anchor2 = new RAPIER.Vector3(0, 1.45, 0);
      const sphericalJoint = RAPIER.JointData.spherical(anchor1, anchor2);
      this.world.createImpulseJoint(sphericalJoint, this.j3Body, this.cardBody, true);
    }
  }

  private async loadAssets() {
    // Load profile image as card texture
    const textureLoader = new THREE.TextureLoader();
    try {
      const profileTexture = await textureLoader.loadAsync('profile.png');

      // Create card with profile image
      const geometry = new THREE.BoxGeometry(1.6, 2.25, 0.02);
      const material = new THREE.MeshStandardMaterial({
        map: profileTexture,
        metalness: 0.1,
        roughness: 0.7
      });
      this.cardMesh = new THREE.Group();
      const mesh = new THREE.Mesh(geometry, material);
      this.cardMesh.add(mesh);
      this.scene.add(this.cardMesh);

      console.log('Profile card texture loaded successfully');
    } catch (error) {
      console.error('Error loading profile image:', error);
      // Create placeholder card
      const geometry = new THREE.BoxGeometry(1.6, 2.25, 0.02);
      const material = new THREE.MeshStandardMaterial({ color: 0xffffff });
      this.cardMesh = new THREE.Group();
      const mesh = new THREE.Mesh(geometry, material);
      this.cardMesh.add(mesh);
      this.scene.add(this.cardMesh);
    }

    // Load lanyard texture and create band
    try {
      const texture = await textureLoader.loadAsync(this.options.lanyardTexturePath);
      texture.wrapS = texture.wrapT = THREE.RepeatWrapping;

      const geometry = new MeshLineGeometry();
      const material = new MeshLineMaterial({
        color: 0xffffff,
        lineWidth: 1,
        resolution: new THREE.Vector2(1000, 1000),
        useMap: 1,
        map: texture,
        repeat: new THREE.Vector2(-4, 1)
      });
      material.depthTest = false;

      this.bandMesh = new THREE.Mesh(geometry, material);
      this.scene.add(this.bandMesh);
    } catch (error) {
      console.error('Error loading lanyard texture:', error);
    }
  }

  private setupEventListeners() {
    this.renderer.domElement.addEventListener('pointermove', this.onPointerMove.bind(this));
    this.renderer.domElement.addEventListener('pointerdown', this.onPointerDown.bind(this));
    this.renderer.domElement.addEventListener('pointerup', this.onPointerUp.bind(this));
    window.addEventListener('resize', this.onResize.bind(this));
  }

  private onPointerMove(event: PointerEvent) {
    const rect = this.renderer.domElement.getBoundingClientRect();
    this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

    if (this.dragged && typeof this.dragged !== 'boolean' && this.cardBody) {
      const vec = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5);
      vec.unproject(this.camera);
      const dir = vec.sub(this.camera.position).normalize();
      vec.add(dir.multiplyScalar(this.camera.position.length()));

      const newPos = vec.sub(this.dragged);
      this.cardBody.setNextKinematicTranslation(newPos);

      // Wake up all bodies
      this.cardBody.wakeUp();
      this.j1Body?.wakeUp();
      this.j2Body?.wakeUp();
      this.j3Body?.wakeUp();
      this.fixedBody?.wakeUp();
    }
  }

  private onPointerDown(event: PointerEvent) {
    if (this.hovered && this.cardMesh && this.cardBody) {
      const vec = new THREE.Vector3();
      const translation = this.cardBody.translation();
      vec.set(translation.x, translation.y, translation.z);

      const pointer = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5);
      pointer.unproject(this.camera);

      this.dragged = pointer.sub(vec);
      this.cardBody.setBodyType(RAPIER.RigidBodyType.KinematicPositionBased, true);
    }
  }

  private onPointerUp() {
    if (this.dragged && this.cardBody) {
      this.dragged = false;
      this.cardBody.setBodyType(RAPIER.RigidBodyType.Dynamic, true);
    }
  }

  private onResize() {
    this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
    this.camera.updateProjectionMatrix();
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
  }

  private animate() {
    this.rafId = requestAnimationFrame(() => this.animate());

    if (this.world) {
      this.world.step();

      // Update lerped positions
      if (this.j1Body && this.j2Body) {
        const j1Trans = this.j1Body.translation();
        const j2Trans = this.j2Body.translation();

        this.j1Lerped.lerp(new THREE.Vector3(j1Trans.x, j1Trans.y, j1Trans.z), 0.1);
        this.j2Lerped.lerp(new THREE.Vector3(j2Trans.x, j2Trans.y, j2Trans.z), 0.1);
      }

      // Update curve points for band
      if (this.j3Body && this.fixedBody && this.bandMesh) {
        const j3Trans = this.j3Body.translation();
        const fixedTrans = this.fixedBody.translation();

        this.curve.points[0].set(j3Trans.x, j3Trans.y, j3Trans.z);
        this.curve.points[1].copy(this.j2Lerped);
        this.curve.points[2].copy(this.j1Lerped);
        this.curve.points[3].set(fixedTrans.x, fixedTrans.y, fixedTrans.z);

        const points = this.curve.getPoints(32);
        (this.bandMesh.geometry as any).setPoints(points);
      }

      // Update card mesh position
      if (this.cardBody && this.cardMesh) {
        const trans = this.cardBody.translation();
        const rot = this.cardBody.rotation();

        this.cardMesh.position.set(trans.x, trans.y, trans.z);
        this.cardMesh.quaternion.set(rot.x, rot.y, rot.z, rot.w);

        // Apply angular damping
        const angVel = this.cardBody.angvel();
        this.cardBody.setAngvel({
          x: angVel.x,
          y: angVel.y - rot.y * 0.25,
          z: angVel.z
        }, true);
      }
    }

    this.renderer.render(this.scene, this.camera);
  }

  public dispose() {
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
    }

    if (this.renderer.domElement.parentNode) {
      this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
    }

    this.renderer.dispose();

    if (this.world) {
      this.world.free();
    }
  }
}
